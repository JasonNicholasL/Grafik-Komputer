<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo Interaktif Vektor & Rasterisasi Segitiga</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; color: white; overflow-x: hidden; }
        canvas { cursor: crosshair; touch-action: none; background: #000; border-radius: 8px; }
        .control-panel { background: rgba(30, 41, 59, 0.9); backdrop-filter: blur(12px); z-index: 50; }
        .mini-canvas { width: 100%; aspect-ratio: 1; background: #000; }
    </style>
</head>
<body class="min-h-screen flex flex-col md:flex-row">

    <!-- Sidebar Kontrol -->
    <div class="control-panel w-full md:w-80 p-6 flex flex-col gap-4 border-r border-slate-700 shadow-xl overflow-y-auto h-screen">
        <div>
            <h1 class="text-xl font-bold text-blue-400">Rasterisasi Segitiga</h1>
            <p class="text-[10px] text-slate-400">Klik 3x di kanvas utama untuk menggambar segitiga baru dengan gradasi warna.</p>
        </div>

        <!-- Color Pickers -->
        <div class="space-y-3 bg-slate-800/50 p-3 rounded-lg border border-slate-700">
            <h2 class="text-xs font-semibold uppercase tracking-widest text-slate-400">Warna Simpul</h2>
            <div class="flex justify-between items-center">
                <label class="text-xs">Titik 1 (A)</label>
                <input type="color" id="color1" value="#ff0000" class="bg-transparent cursor-pointer">
            </div>
            <div class="flex justify-between items-center">
                <label class="text-xs">Titik 2 (B)</label>
                <input type="color" id="color2" value="#00ff00" class="bg-transparent cursor-pointer">
            </div>
            <div class="flex justify-between items-center">
                <label class="text-xs">Titik 3 (C)</label>
                <input type="color" id="color3" value="#0000ff" class="bg-transparent cursor-pointer">
            </div>
        </div>

        <!-- Mode Toggle -->
        <button id="resetPoints" class="w-full bg-blue-600 hover:bg-blue-500 py-2 rounded text-xs font-bold transition">
            Reset Klik Titik
        </button>

        <!-- Komponen RGB -->
        <div class="space-y-4 pt-4 border-t border-slate-700">
            <h2 class="text-xs font-semibold uppercase tracking-widest text-slate-400 text-center">Komponen Warna (RGB)</h2>
            <div class="grid grid-cols-1 gap-2">
                <div>
                    <p class="text-[10px] text-red-400 mb-1 text-center font-bold">RED CHANNEL</p>
                    <canvas id="canvasR" class="mini-canvas border border-red-500/20"></canvas>
                </div>
                <div>
                    <p class="text-[10px] text-green-400 mb-1 text-center font-bold">GREEN CHANNEL</p>
                    <canvas id="canvasG" class="mini-canvas border border-green-500/20"></canvas>
                </div>
                <div>
                    <p class="text-[10px] text-blue-400 mb-1 text-center font-bold">BLUE CHANNEL</p>
                    <canvas id="canvasB" class="mini-canvas border border-blue-500/20"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- Area Kanvas Utama -->
    <div id="canvas-container" class="flex-grow relative flex items-center justify-center bg-slate-950 p-4">
        <canvas id="vizCanvas"></canvas>
        <div class="absolute bottom-4 left-6 text-slate-500 text-[10px] uppercase tracking-widest pointer-events-none select-none">
            Klik kanvas untuk menentukan 3 titik sudut segitiga
        </div>
    </div>

    <script>
        const canvas = document.getElementById('vizCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        // Color Pickers
        const col1Input = document.getElementById('color1');
        const col2Input = document.getElementById('color2');
        const col3Input = document.getElementById('color3');
        const resetBtn = document.getElementById('resetPoints');

        // Mini Canvases
        const canvasR = document.getElementById('canvasR');
        const canvasG = document.getElementById('canvasG');
        const canvasB = document.getElementById('canvasB');

        let points = []; // Menyimpan maksimal 3 titik {x, y}
        
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function resize() {
            canvas.width = container.clientWidth - 40;
            canvas.height = container.clientHeight - 40;
            
            // Set mini canvases
            [canvasR, canvasG, canvasB].forEach(c => {
                c.width = 150;
                c.height = 150;
            });
            draw();
        }

        // Fungsi Barycentric Coordinates untuk menentukan apakah pixel di dalam segitiga
        // dan mendapatkan rasio interpolasi warna
        function getBarycentric(p, a, b, c) {
            const det = (b.y - c.y) * (a.x - c.x) + (c.x - b.x) * (a.y - c.y);
            const w1 = ((b.y - c.y) * (p.x - c.x) + (c.x - b.x) * (p.y - c.y)) / det;
            const w2 = ((c.y - a.y) * (p.x - c.x) + (a.x - c.x) * (p.y - c.y)) / det;
            const w3 = 1 - w1 - w2;
            return { w1, w2, w3 };
        }

        function rasterizeTriangle() {
            if (points.length < 3) return;

            const c1 = hexToRgb(col1Input.value);
            const c2 = hexToRgb(col2Input.value);
            const c3 = hexToRgb(col3Input.value);

            const p1 = points[0], p2 = points[1], p3 = points[2];

            // Hitung bounding box agar tidak scan seluruh kanvas
            const minX = Math.floor(Math.min(p1.x, p2.x, p3.x));
            const maxX = Math.ceil(Math.max(p1.x, p2.x, p3.x));
            const minY = Math.floor(Math.min(p1.y, p2.y, p3.y));
            const maxY = Math.ceil(Math.max(p1.y, p2.y, p3.y));

            const imgData = ctx.createImageData(canvas.width, canvas.height);
            const data = imgData.data;

            // Mini canvas data
            const imgDataR = canvasR.getContext('2d').createImageData(canvasR.width, canvasR.height);
            const imgDataG = canvasG.getContext('2d').createImageData(canvasG.width, canvasG.height);
            const imgDataB = canvasB.getContext('2d').createImageData(canvasB.width, canvasB.height);

            // Kita gunakan rasio skala untuk mini kanvas
            const scaleX = canvasR.width / canvas.width;
            const scaleY = canvasR.height / canvas.height;

            for (let y = minY; y <= maxY; y++) {
                if (y < 0 || y >= canvas.height) continue;
                for (let x = minX; x <= maxX; x++) {
                    if (x < 0 || x >= canvas.width) continue;

                    const bar = getBarycentric({x, y}, p1, p2, p3);

                    if (bar.w1 >= 0 && bar.w2 >= 0 && bar.w3 >= 0) {
                        const r = bar.w1 * c1.r + bar.w2 * c2.r + bar.w3 * c3.r;
                        const g = bar.w1 * c1.g + bar.w2 * c2.g + bar.w3 * c3.g;
                        const b = bar.w1 * c1.b + bar.w2 * c2.b + bar.w3 * c3.b;

                        const idx = (y * canvas.width + x) * 4;
                        data[idx] = r;
                        data[idx + 1] = g;
                        data[idx + 2] = b;
                        data[idx + 3] = 255;

                        // Fill mini canvases (interpolasi posisi sederhana)
                        const mx = Math.floor(x * scaleX);
                        const my = Math.floor(y * scaleY);
                        if (mx >= 0 && mx < canvasR.width && my >= 0 && my < canvasR.height) {
                            const midx = (my * canvasR.width + mx) * 4;
                            // Red Channel Canvas
                            imgDataR.data[midx] = r; imgDataR.data[midx+3] = 255;
                            // Green Channel Canvas
                            imgDataG.data[midx+1] = g; imgDataG.data[midx+3] = 255;
                            // Blue Channel Canvas
                            imgDataB.data[midx+2] = b; imgDataB.data[midx+3] = 255;
                        }
                    }
                }
            }
            ctx.putImageData(imgData, 0, 0);
            canvasR.getContext('2d').putImageData(imgDataR, 0, 0);
            canvasG.getContext('2d').putImageData(imgDataG, 0, 0);
            canvasB.getContext('2d').putImageData(imgDataB, 0, 0);
        }

        function draw() {
            ctx.fillStyle = "#000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Bersihkan mini canvases
            [canvasR, canvasG, canvasB].forEach(c => {
                const mctx = c.getContext('2d');
                mctx.fillStyle = "#000";
                mctx.fillRect(0, 0, c.width, c.height);
            });

            if (points.length === 3) {
                rasterizeTriangle();
            }

            // Gambar titik panduan
            points.forEach((p, i) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = i === 0 ? col1Input.value : (i === 1 ? col2Input.value : col3Input.value);
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2;
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = "white";
                ctx.fillText(`P${i+1}`, p.x + 10, p.y - 10);
            });
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (points.length >= 3) {
                points = []; // Reset jika sudah ada 3
            }
            
            points.push({ x, y });
            draw();
        });

        resetBtn.addEventListener('click', () => {
            points = [];
            draw();
        });

        [col1Input, col2Input, col3Input].forEach(inp => {
            inp.addEventListener('input', draw);
        });

        window.addEventListener('resize', resize);
        setTimeout(resize, 50);

    </script>
</body>
</html>
