<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo Interaktif Vektor & Cross Product</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #0f172a; color: white; overflow: hidden; }
        canvas { cursor: crosshair; touch-action: none; background: radial-gradient(circle at center, #1e293b 0%, #0f172a 100%); }
        .control-panel { background: rgba(30, 41, 59, 0.9); backdrop-filter: blur(12px); z-index: 50; }
        input[type=number]::-webkit-inner-spin-button { opacity: 1; }
    </style>
</head>
<body class="min-h-screen flex flex-col md:flex-row">

    <!-- Sidebar Kontrol -->
    <div class="control-panel w-full md:w-80 p-6 flex flex-col gap-6 border-r border-slate-700 shadow-xl overflow-y-auto h-1/3 md:h-full">
        <div>
            <h1 class="text-xl font-bold mb-2 text-blue-400">Vektor Interaktif</h1>
            <p class="text-xs text-slate-400">Tarik titik putih di ujung panah untuk memindahkan vektor di bidang XY.</p>
        </div>

        <!-- Vektor A -->
        <div class="space-y-3 p-3 rounded-lg border border-red-500/20 bg-red-500/5">
            <h2 class="text-sm font-semibold text-red-400 uppercase tracking-wider flex justify-between">
                <span>Vektor A</span>
                <span class="text-[10px] opacity-50">MERAH</span>
            </h2>
            <div class="grid grid-cols-3 gap-2">
                <div><label class="block text-[10px] text-slate-500">X</label><input type="number" id="ax" step="0.5" class="w-full bg-slate-900 border border-slate-700 rounded p-1 text-sm"></div>
                <div><label class="block text-[10px] text-slate-500">Y</label><input type="number" id="ay" step="0.5" class="w-full bg-slate-900 border border-slate-700 rounded p-1 text-sm"></div>
                <div><label class="block text-[10px] text-slate-500">Z</label><input type="number" id="az" step="0.5" class="w-full bg-slate-900 border border-slate-700 rounded p-1 text-sm"></div>
            </div>
        </div>

        <!-- Vektor B -->
        <div class="space-y-3 p-3 rounded-lg border border-blue-500/20 bg-blue-500/5">
            <h2 class="text-sm font-semibold text-blue-400 uppercase tracking-wider flex justify-between">
                <span>Vektor B</span>
                <span class="text-[10px] opacity-50">BIRU</span>
            </h2>
            <div class="grid grid-cols-3 gap-2">
                <div><label class="block text-[10px] text-slate-500">X</label><input type="number" id="bx" step="0.5" class="w-full bg-slate-900 border border-slate-700 rounded p-1 text-sm"></div>
                <div><label class="block text-[10px] text-slate-500">Y</label><input type="number" id="by" step="0.5" class="w-full bg-slate-900 border border-slate-700 rounded p-1 text-sm"></div>
                <div><label class="block text-[10px] text-slate-500">Z</label><input type="number" id="bz" step="0.5" class="w-full bg-slate-900 border border-slate-700 rounded p-1 text-sm"></div>
            </div>
        </div>

        <!-- Opsi -->
        <div class="pt-4 border-t border-slate-700">
            <label class="flex items-center cursor-pointer gap-3 group">
                <div class="relative">
                    <input type="checkbox" id="normalizeToggle" class="sr-only">
                    <div class="w-10 h-5 bg-slate-700 rounded-full shadow-inner group-hover:bg-slate-600 transition"></div>
                    <div class="dot absolute left-1 top-1 bg-white w-3 h-3 rounded-full transition-all"></div>
                </div>
                <span class="text-sm font-medium">Normalisasi Normal (n̂)</span>
            </label>
        </div>

        <!-- Output Info -->
        <div id="stats" class="bg-slate-900/80 p-4 rounded-lg text-xs font-mono space-y-2 border border-green-500/30">
            <div class="text-green-400 font-bold border-b border-green-500/20 pb-1">HASIL CROSS PRODUCT (A × B):</div>
            <div id="crossResult" class="text-slate-300 text-sm">V: [0, 0, 0]</div>
            <div id="crossMag" class="text-slate-400">Magnitudo: 0.00</div>
        </div>
    </div>

    <!-- Area Kanvas -->
    <div id="canvas-container" class="flex-grow relative flex items-center justify-center bg-slate-950">
        <canvas id="vizCanvas"></canvas>
        <div class="absolute bottom-6 left-6 text-slate-500 text-[10px] uppercase tracking-widest pointer-events-none select-none">
            Proyeksi Isometrik: Geser titik putih di ujung vektor
        </div>
    </div>

    <style>
        input:checked ~ .dot { transform: translateX(20px); background-color: #4ade80; }
        input:checked ~ div:first-child { background-color: #065f46; }
    </style>

    <script>
        const canvas = document.getElementById('vizCanvas');
        const ctx = canvas.getContext('2d');
        const statsEl = document.getElementById('crossResult');
        const magEl = document.getElementById('crossMag');
        const normalizeToggle = document.getElementById('normalizeToggle');
        const container = document.getElementById('canvas-container');

        // State Vektor (Inisialisasi lebih variatif agar terlihat 3D-nya)
        let vecA = { x: 3, y: 0, z: 0 };
        let vecB = { x: 0, y: 3, z: 0 };
        let dragging = null;

        const scale = 45; 
        let centerX, centerY;

        const inputs = {
            ax: document.getElementById('ax'), ay: document.getElementById('ay'), az: document.getElementById('az'),
            bx: document.getElementById('bx'), by: document.getElementById('by'), bz: document.getElementById('bz')
        };

        function updateInputsUI() {
            inputs.ax.value = vecA.x; inputs.ay.value = vecA.y; inputs.az.value = vecA.z;
            inputs.bx.value = vecB.x; inputs.by.value = vecB.y; inputs.bz.value = vecB.z;
        }

        Object.keys(inputs).forEach(key => {
            inputs[key].addEventListener('input', (e) => {
                const val = parseFloat(e.target.value) || 0;
                const axis = key[1];
                if (key.startsWith('a')) vecA[axis] = val;
                else vecB[axis] = val;
                draw();
            });
        });

        normalizeToggle.addEventListener('change', draw);

        function project(x, y, z) {
            const cos30 = Math.cos(Math.PI / 6);
            const sin30 = Math.sin(Math.PI / 6);
            // Standar Isometrik: x & y membentuk sudut 30 derajat ke bawah, z tegak lurus
            const screenX = centerX + (x - y) * cos30 * scale;
            const screenY = centerY - (z * scale) + (x + y) * sin30 * scale;
            return { x: screenX, y: screenY };
        }

        function unproject(sx, sy, currentZ = 0) {
            const cos30 = Math.cos(Math.PI / 6);
            const sin30 = Math.sin(Math.PI / 6);
            
            // Kompensasi koordinat layar terhadap titik pusat dan ketinggian Z
            const ty = (sy - centerY + (currentZ * scale)) / (sin30 * scale);
            const tx = (sx - centerX) / (cos30 * scale);

            return {
                x: (tx + ty) / 2,
                y: (ty - tx) / 2
            };
        }

        function resize() {
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            centerX = canvas.width / 2;
            centerY = canvas.height / 2 + 50;
            draw();
        }

        function drawArrow(from, to, color, label, width = 3, isGhost = false) {
            const headlen = 14;
            const dx = to.x - from.x;
            const dy = to.y - from.y;
            const angle = Math.atan2(dy, dx);

            ctx.save();
            if (isGhost) ctx.globalAlpha = 0.2;
            
            ctx.beginPath();
            ctx.moveTo(from.x, from.y);
            ctx.lineTo(to.x, to.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Arrow head
            ctx.beginPath();
            ctx.moveTo(to.x, to.y);
            ctx.lineTo(to.x - headlen * Math.cos(angle - Math.PI / 8), to.y - headlen * Math.sin(angle - Math.PI / 8));
            ctx.lineTo(to.x - headlen * Math.cos(angle + Math.PI / 8), to.y - headlen * Math.sin(angle + Math.PI / 8));
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();

            // Label
            ctx.font = 'bold 14px sans-serif';
            ctx.shadowBlur = 4;
            ctx.shadowColor = 'black';
            ctx.fillText(label, to.x + 15, to.y + 5);
            ctx.restore();
        }

        function drawGrid() {
            ctx.strokeStyle = '#334155';
            ctx.lineWidth = 1;
            const range = 8;

            for (let i = -range; i <= range; i++) {
                const p1 = project(i, -range, 0);
                const p2 = project(i, range, 0);
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();

                const p3 = project(-range, i, 0);
                const p4 = project(range, i, 0);
                ctx.beginPath(); ctx.moveTo(p3.x, p3.y); ctx.lineTo(p4.x, p4.y); ctx.stroke();
            }

            const origin = project(0,0,0);
            drawArrow(origin, project(2,0,0), '#ef4444', 'X', 1, true);
            drawArrow(origin, project(0,2,0), '#3b82f6', 'Y', 1, true);
            drawArrow(origin, project(0,0,2), '#ffffff', 'Z', 1, true);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();

            const origin = project(0, 0, 0);
            const pA = project(vecA.x, vecA.y, vecA.z);
            const pB = project(vecB.x, vecB.y, vecB.z);

            // Cross Product Calculation: A x B
            const cx = vecA.y * vecB.z - vecA.z * vecB.y;
            const cy = vecA.z * vecB.x - vecA.x * vecB.z;
            const cz = vecA.x * vecB.y - vecA.y * vecB.x;
            const mag = Math.sqrt(cx*cx + cy*cy + cz*cz);

            let normalX = cx, normalY = cy, normalZ = cz;
            if (normalizeToggle.checked && mag > 0) {
                normalX /= mag; normalY /= mag; normalZ /= mag;
            }
            const pNormal = project(normalX, normalY, normalZ);

            // Segitiga Bidang
            ctx.beginPath();
            ctx.moveTo(origin.x, origin.y);
            ctx.lineTo(pA.x, pA.y);
            ctx.lineTo(pB.x, pB.y);
            ctx.closePath();
            ctx.fillStyle = 'rgba(56, 189, 248, 0.2)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.setLineDash([2, 2]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw Vectors
            drawArrow(origin, pA, '#f87171', 'A', 4);
            drawArrow(origin, pB, '#60a5fa', 'B', 4);
            
            if (mag > 0.001) {
                drawArrow(origin, pNormal, '#4ade80', normalizeToggle.checked ? 'n̂' : 'A×B', 5);
            }

            // Interactive Handles (Bulatan Putih)
            [pA, pB].forEach((p, i) => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
                ctx.fillStyle = 'white';
                ctx.shadowBlur = 10;
                ctx.shadowColor = i === 0 ? 'red' : 'blue';
                ctx.fill();
                ctx.shadowBlur = 0;
            });

            // Update UI
            statsEl.innerText = `V: [${cx.toFixed(2)}, ${cy.toFixed(2)}, ${cz.toFixed(2)}]`;
            magEl.innerText = `Magnitudo: ${mag.toFixed(2)}`;
            updateInputsUI();
        }

        // Pointer Logic
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function onDown(e) {
            const pos = getPointerPos(e);
            const pA = project(vecA.x, vecA.y, vecA.z);
            const pB = project(vecB.x, vecB.y, vecB.z);

            // Cek jarak klik ke ujung A atau B (radius toleransi 30px)
            if (Math.hypot(pos.x - pA.x, pos.y - pA.y) < 30) {
                dragging = 'A';
            } else if (Math.hypot(pos.x - pB.x, pos.y - pB.y) < 30) {
                dragging = 'B';
            }
        }

        function onMove(e) {
            if (!dragging) return;
            const pos = getPointerPos(e);
            
            const targetVec = dragging === 'A' ? vecA : vecB;
            // Gunakan unproject dengan mempertahankan nilai Z yang ada agar tidak meloncat ke 0
            const world = unproject(pos.x, pos.y, targetVec.z);
            
            // Snap ke 0.5 unit untuk kemudahan
            targetVec.x = Math.round(world.x * 2) / 2;
            targetVec.y = Math.round(world.y * 2) / 2;
            
            draw();
        }

        function onUp() {
            dragging = null;
        }

        // Event Listeners
        canvas.addEventListener('mousedown', onDown);
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);

        canvas.addEventListener('touchstart', (e) => {
            onDown(e);
            e.preventDefault();
        }, { passive: false });
        window.addEventListener('touchmove', (e) => {
            onMove(e);
        }, { passive: false });
        window.addEventListener('touchend', onUp);

        window.addEventListener('resize', resize);
        
        // Boot
        setTimeout(resize, 50);

    </script>
</body>
</html>